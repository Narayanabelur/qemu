//
// Created by nbel0004 on 17/9/19.
//

#include "hw/usb/hid_scancodes.h"
#include "hw/usb/ascii_hex.h"

#ifndef QEMU_CHAR_TO_SCANCODES_MAP_H
#define QEMU_CHAR_TO_SCANCODES_MAP_H
typedef struct {
    uint8_t mod;
    uint8_t key;
} key_decoder;

const key_decoder char_to_scancodes[256] = {
        [CHAR_SPACE] = (key_decoder){.mod = KEY_NONE, .key = KEY_SPACE},
        [CHAR_EXCLAMATION] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_1},
        [CHAR_DOUBLE_QUOTE] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_APOSTROPHE},
        [CHAR_POUND] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_3},
        [CHAR_DOLLAR] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_4 },
        [CHAR_PERCENTAGE] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_5},
        [CHAR_AMPERSAND] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_7},
        [CHAR_SINGLE_QUOTE] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_APOSTROPHE},
        [CHAR_OPEN_BRACKET] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_9},
        [CHAR_CLOSE_BRACKET] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_0},
        [CHAR_STAR] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_8},
        [CHAR_PLUS] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_KPPLUS },
        [CHAR_COMMA] = (key_decoder){.mod = KEY_NONE, .key = KEY_COMMA},
        [CHAR_HYPHEN] = (key_decoder){.mod = KEY_NONE, .key = KEY_MINUS},
        [CHAR_PERIOD] = (key_decoder){.mod = KEY_NONE, .key = KEY_DOT},
        [CHAR_SLASH] = (key_decoder){.mod = KEY_NONE, .key = KEY_SLASH},
        [CHAR_0] = (key_decoder){.mod = KEY_NONE, .key = KEY_0},
        [CHAR_1] = (key_decoder){.mod = KEY_NONE, .key = KEY_1},
        [CHAR_2] = (key_decoder){.mod = KEY_NONE, .key = KEY_2},
        [CHAR_3] = (key_decoder){.mod = KEY_NONE, .key = KEY_3},
        [CHAR_4] = (key_decoder){.mod = KEY_NONE, .key = KEY_4},
        [CHAR_5] = (key_decoder){.mod = KEY_NONE, .key = KEY_5},
        [CHAR_6] = (key_decoder){.mod = KEY_NONE, .key = KEY_6},
        [CHAR_7] = (key_decoder){.mod = KEY_NONE, .key = KEY_7},
        [CHAR_8] = (key_decoder){.mod = KEY_NONE, .key = KEY_8},
        [CHAR_9] = (key_decoder){.mod = KEY_NONE, .key = KEY_9},
        [CHAR_COLON] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_SEMICOLON},
        [CHAR_SEMICOLON] = (key_decoder){.mod = KEY_NONE, .key = KEY_SEMICOLON},
        [CHAR_LESS_THAN] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_COMMA},
        [CHAR_EQUALS] = (key_decoder){.mod = KEY_NONE, .key = KEY_EQUAL},
        [CHAR_RIGHT_THAN] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_DOT},
        [CHAR_QUESTION_MARK] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_SLASH},
        [CHAR_AT_SYMBOL] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_2},
        [CHAR_A] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_A},
        [CHAR_B] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_B},
        [CHAR_C] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_C},
        [CHAR_D] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_D},
        [CHAR_E] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_E},
        [CHAR_F] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_F},
        [CHAR_G] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_G},
        [CHAR_H] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_H},
        [CHAR_I] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_I},
        [CHAR_J] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_J},
        [CHAR_K] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_K},
        [CHAR_L] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_L},
        [CHAR_M] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_M},
        [CHAR_N] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_N},
        [CHAR_O] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_O},
        [CHAR_P] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_P},
        [CHAR_Q] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_Q},
        [CHAR_R] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_R},
        [CHAR_S] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_S},
        [CHAR_T] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_T},
        [CHAR_U] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_U},
        [CHAR_V] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_V},
        [CHAR_W] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_W},
        [CHAR_X] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_X},
        [CHAR_Y] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_Y},
        [CHAR_Z] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_Z},
        [CHAR_OPEN_SQUARE_BRACKET] = (key_decoder){.mod = KEY_NONE, .key = KEY_LEFTBRACE},
        [CHAR_BACKSLASH] = (key_decoder){.mod = KEY_NONE, .key = KEY_BACKSLASH},
        [CHAR_CLOSE_SQUARE_BRACKET] = (key_decoder){.mod = KEY_NONE, .key = KEY_RIGHTBRACE},
        [CHAR_CAROT] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_6},
        [CHAR_UNDERSCORE] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_MINUS},
        [CHAR_BACKTICK] = (key_decoder){.mod = KEY_NONE, .key = KEY_GRAVE},
        [CHAR_a] = (key_decoder){.mod = KEY_NONE, .key = KEY_A},
        [CHAR_b] = (key_decoder){.mod = KEY_NONE, .key = KEY_B},
        [CHAR_c] = (key_decoder){.mod = KEY_NONE, .key = KEY_C},
        [CHAR_d] = (key_decoder){.mod = KEY_NONE, .key = KEY_D},
        [CHAR_e] = (key_decoder){.mod = KEY_NONE, .key = KEY_E},
        [CHAR_f] = (key_decoder){.mod = KEY_NONE, .key = KEY_F},
        [CHAR_g] = (key_decoder){.mod = KEY_NONE, .key = KEY_G},
        [CHAR_h] = (key_decoder){.mod = KEY_NONE, .key = KEY_H},
        [CHAR_i] = (key_decoder){.mod = KEY_NONE, .key = KEY_I},
        [CHAR_j] = (key_decoder){.mod = KEY_NONE, .key = KEY_J},
        [CHAR_k] = (key_decoder){.mod = KEY_NONE, .key = KEY_K},
        [CHAR_l] = (key_decoder){.mod = KEY_NONE, .key = KEY_L},
        [CHAR_m] = (key_decoder){.mod = KEY_NONE, .key = KEY_M},
        [CHAR_n] = (key_decoder){.mod = KEY_NONE, .key = KEY_N},
        [CHAR_o] = (key_decoder){.mod = KEY_NONE, .key = KEY_O},
        [CHAR_p] = (key_decoder){.mod = KEY_NONE, .key = KEY_P},
        [CHAR_q] = (key_decoder){.mod = KEY_NONE, .key = KEY_Q},
        [CHAR_r] = (key_decoder){.mod = KEY_NONE, .key = KEY_R},
        [CHAR_s] = (key_decoder){.mod = KEY_NONE, .key = KEY_S},
        [CHAR_t] = (key_decoder){.mod = KEY_NONE, .key = KEY_T},
        [CHAR_u] = (key_decoder){.mod = KEY_NONE, .key = KEY_U},
        [CHAR_v] = (key_decoder){.mod = KEY_NONE, .key = KEY_V},
        [CHAR_w] = (key_decoder){.mod = KEY_NONE, .key = KEY_W},
        [CHAR_x] = (key_decoder){.mod = KEY_NONE, .key = KEY_X},
        [CHAR_y] = (key_decoder){.mod = KEY_NONE, .key = KEY_Y},
        [CHAR_z] = (key_decoder){.mod = KEY_NONE, .key = KEY_Z},
        [CHAR_OPEN_BRACE] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_LEFTBRACE},
        [CHAR_PIPE] = (key_decoder){.mod = KEY_MOD_LSHIFT , .key = KEY_BACKSLASH},
        [CHAR_CLOSE_BRACE] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_RIGHTBRACE},
        [CHAR_TILDE] = (key_decoder){.mod = KEY_MOD_LSHIFT, .key = KEY_HASHTILDE},
        [CHAR_NEWLINE] = (key_decoder){.mod = KEY_NONE, .key = KEY_ENTER}
};
#endif //QEMU_CHAR_TO_SCANCODES_MAP_H
